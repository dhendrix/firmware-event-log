#summary Firmware Event Log

Based off work by Tim Hockin @ Google, Inc, 2006

Documentation License:

[http://creativecommons.org/licenses/by/3.0/us/ http://i.creativecommons.org/l/by/3.0/us/88x31.png]  [http://creativecommons.org/licenses/by/3.0/us/ Creative Commons Attribution 3.0 United States License]

The goal of this project is to provide a standards-based event log that is suitable for storage in non-volatile memory, such as EEPROM.

==Background==

Modern firmware implementations often reserve a small region in non-volatile memory to store diagnostic and debugging information. However, there is no universal standard for the format. There is no standard location for the log to reside. And there is no standard, free/open-source code to store and retrieve records.

Google's firmware event log format is based off of a well-understood standard format -- SMBIOS System Event Log (Type 15). SMBIOS, however, usually exists strictly in RAM. We require that the event is stored persistently so that information about it can be retrieved at any later point in time, so we have defined methods to store the data in non-volatile memory (assumed to be flash memory).

This event log will store information about events critical to system operation. Such events include DRAM errors, bus failures, and arbitrary OEM-defined events such as basic kernel crash information and crisis recovery notification. The events which are logged are implementation-specific.

==Terminology==

SMBIOS: System Management BIOS.
SMBIOS is a public specification which defines structured data about the system and methods for accessing that data.

    * http://www.dmtf.org/standards/smbios/

==Overview==

What we want is a way to keep track of a few dozen or possibly hundreds of events persistently across power cycles and reboots.

We will use a log in the system flash (memory mapped), which can be safely shrunk and copied with a double-buffered copy-and-shrink operation (more in the "Log shrinking" section below). We will enable logging of significant events which occur any time the system is in a running state, whether it's booting or whether the OS is operational.

This will provide rich, detailed information about the recent history of a system, which can help us when diagnosing systemic problems, both during platform development as well as after deployment. 

==Detailed Design==

The SMBIOS specification defines that the event log consists of an arbitrary length header (0 length is valid), followed immediately by the log data. There are a number of options for log access method, the simplest of which is memory-mapped. We will be using the system flash (which is usually already memory mapped) to store the event log.

The SMBIOS Event Log specification is not perfect, and creates a few rather unfortunate limitations. The largest possible event log, including any header is 65535 (0xffff) bytes. We will make our log as large as allowed. The last byte of the 64 KB flash sector will be left as 0xff, which is conveniently the end-of-log marker.

Log data is stored as a series of variable-length event records in chronological order. The SMBIOS specification does not provide for ring-buffer semantics, which makes for a less than ideal failure mode. If the log reaches capacity, the log is simply marked as full. In order to avoid this failure mode we will check the log size whenever we write an event. If the log has crossed a size threshold, the log will be automatically shrunk and relocated (for a safe copy operation - see "Log shrinking" below).

===Log header===

The event log header is found at the start of the log area. It can be either a standard format or an OEM-specific format. We will define it as an OEM-specific packed structure with the following layout: 
{{{
struct elog_header {
        uint32_t elog_magic;      /* "ELOG" when read as bytes, 0x474f4c45 when read as a DWORD */

        int32_t  elog_sequence;   /* log sequence number */

        uint8_t  elog_version;    /* log header version */
        uint8_t  elog_size;       /* log header size */
        uint8_t  reserved1;       /* reserved (0xff) */

        uint8_t  reserved2;       /* reserved (0xff) */

        uint8_t  elog_data[0];    /* log data */
};
}}}

The *elog_magic* field is used to identify the active log area. Since we will be using a two buffer areas, the signature could be at either of two locations. 